<#@ template language="C#v3.5" debug="True" hostspecific="True" #>
<#@ output extension=".cs" #>
<#@ assembly name="SubSonic.dll" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="SubSonic" #>
<#@ include file="Settings.ttinclude" #>
<#@ include file="Data.Common.ttinclude" #>
<#
    //SubSonicSection section = (SubSonicSection)Config.GetSection(ConfigurationSectionName.SUB_SONIC_SERVICE);
    //if (section != null)
    //{
    //    string DefaultProvider = section.DefaultProvider;
    //    if (!string.IsNullOrEmpty(DefaultProvider))
    //    {
    //        ProviderSettings CurrentProvider = section.Providers[DefaultProvider];
    //        if (CurrentProvider != null)
    //        {
    //            ConnectionName = CurrentProvider.Parameters["connectionStringName"].ToString();
    //        }
    //    }
    //}

    ConnectionName = "Northwind";
    Namespace = "Northwind";

    DbSchema schema = new DbSchema(ConnectionString, ProviderName);
    DataTable tables = schema.GetTables();
    DataTable views = schema.GetViews();
#>
//  Generated on <#=DateTime.Now.ToString()#> by <#=Environment.UserName #>
// <auto-generated />

using System;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration;
using System.Xml;
using System.Xml.Serialization;
using SubSonic;
using SubSonic.Utilities;

namespace <#=Namespace #>
{
<#
    foreach(DataRow row in tables.Rows)
    {
		string tableName = row["TABLE_NAME"].ToString();
        string className = Inflector.MakeSingular(CleanName(tableName));
        string tableSchema = row["TABLE_SCHEMA"].ToString();
        DataTable tableColumns = schema.GetTableColumns(tableSchema, tableName);
#>

    /// <summary>
    /// Strongly-typed collection for the <#=className #> class.
    /// </summary>
    [Serializable]
    public partial class <#=className #>Collection : ActiveList<<#=className #>, <#=className #>Collection>
    {
        public <#=className #>Collection() {}

        /// <summary>
        /// Filters an existing collection based on the set criteria. This is an in-memory filter
        /// Thanks to developingchris for this!
        /// </summary>
        /// <returns><#=className #>Collection</returns>
        public <#=className #>Collection Filter()
        {
            for (int i = this.Count - 1; i > -1; i--)
            {
                <#=className #> o = this[i];
                foreach (SubSonic.Where w in this.wheres)
                {
                    bool remove = false;
                    System.Reflection.PropertyInfo pi = o.GetType().GetProperty(w.ColumnName);
                    if (pi.CanRead)
                    {
                        object val = pi.GetValue(o, null);
                        switch (w.Comparison)
                        {
                            case SubSonic.Comparison.Equals:
                                if (!val.Equals(w.ParameterValue))
                                {
                               		remove = true;
                                }
                                break;
                        }
                    }

                    if (remove)
                    {
                        this.Remove(o);
                        break;
                    }
                }
            }
            return this;
        }
    }

    /// <summary>
    /// This is an ActiveRecord class which wraps the [<#=tableName #>] table.
    /// </summary>
    [Serializable]
    public class <#=className #> : ActiveRecord<<#=className #>>, IActiveRecord
    {

        #region ' .Ctors and Default Settings '

        public <#=className #>()
        {
            SetSQLProps();
            InitSetDefaults();
            MarkNew();
        }

        private void InitSetDefaults() { SetDefaults(); }

        public <#=className #>(bool useDatabaseDefaults)
        {
            SetSQLProps();
            if(useDatabaseDefaults)
                ForceDefaults();
            MarkNew();
        }

        public <#=className #>(object keyID)
        {
            SetSQLProps();
            InitSetDefaults();
            LoadByKey(keyID);
        }

        public <#=className #>(string columnName, object columnValue)
        {
            SetSQLProps();
            InitSetDefaults();
            LoadByParam(columnName,columnValue);
        }

        protected static void SetSQLProps() { GetTableSchema(); }

        #endregion

        #region ' Schema and Query Accessor '

        public static Query CreateQuery() { return new Query(Schema); }

        public static TableSchema.Table Schema
        {
            get
            {
                if (BaseSchema == null)
                    SetSQLProps();
                return BaseSchema;
            }
        }

        private static void GetTableSchema()
        {
            if(!IsSchemaInitialized)
            {
                //Schema declaration
                TableSchema.Table schema = new TableSchema.Table("<#=tableName #>", TableType.Table, DataService.GetInstance("<#=ConnectionName #>"));
                schema.Columns = new TableSchema.TableColumnCollection();
                schema.SchemaName = @"<#=tableSchema #>";

                // Columns
<#
        DataTable ForeignKeys = schema.GetTableManyToOneRelations(tableSchema, tableName);
        foreach(DataRow columnRow in tableColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
            DbType dbType = schema.GetDbColumnType(columnRow["ProviderType"].ToString());
            Type dataType = (Type)columnRow["DataType"];
            string systemType = schema.GetPropertyType(dataType.ToString());
            string ColumnSize = "0";
            if (systemType == "string")
                ColumnSize = columnRow["ColumnSize"].ToString();
            bool isAutoIncrement = (bool)columnRow["IsAutoIncrement"];
            bool isNullable = (bool)columnRow["AllowDBNull"];
            bool isPrimaryKey = (bool)columnRow["IsKey"];
            bool isForeignKey = false;
            string foreignKeyTable = string.Empty;
            DataRow[] ForeignKeyOnColumn = ForeignKeys.Select(string.Format("FK_COLUMN_NAME = '{0}'", columnName));
            if (ForeignKeyOnColumn.Length > 0)
            {
                isForeignKey = true;
                foreignKeyTable = ForeignKeyOnColumn[0]["FK_TABLE_NAME"].ToString();
            }
            bool isReadOnly = (bool)columnRow["IsReadOnly"];
#>
                TableSchema.TableColumn column<#=propertyName #> = new TableSchema.TableColumn(schema);
                column<#=propertyName #>.ColumnName = "<#=columnName #>";
                column<#=propertyName #>.DataType = DbType.<#=dbType.ToString() #>;
                column<#=propertyName #>.MaxLength = <#=ColumnSize #>;
                column<#=propertyName #>.AutoIncrement = <#=isAutoIncrement.ToString().ToLower() #>;
                column<#=propertyName #>.IsNullable = <#=isNullable.ToString().ToLower() #>;
                column<#=propertyName #>.IsPrimaryKey = <#=isPrimaryKey.ToString().ToLower() #>;
                column<#=propertyName #>.IsForeignKey = <#=isForeignKey.ToString().ToLower() #>;
<#
            if (isForeignKey)
            {
#>
                column<#=propertyName #>.ForeignKeyTableName = "<#=foreignKeyTable #>";
<#
            }
#>
                column<#=propertyName #>.IsReadOnly = <#=isReadOnly.ToString().ToLower() #>;
                schema.Columns.Add(column<#=propertyName #>);

<#
        }

#>
                BaseSchema = schema;

                //add this schema to the provider
                //so we can query it later
                DataService.Providers["<#=ConnectionName #>"].AddSchema("<#=tableName #>", schema);
            }
        }

        #endregion

        #region ' Properties '

<#
        foreach (DataRow columnRow in tableColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
            DbType dbType = schema.GetDbColumnType(columnRow["ProviderType"].ToString());
            Type dataType = (Type)columnRow["DataType"];
            string systemType = schema.GetPropertyType(dataType.ToString());
#>
        [XmlAttribute("<#=propertyName #>")]
        [Bindable(true)]
        public <#=systemType #> <#=propertyName #>
        {
            get { return GetColumnValue<<#=systemType #>>(Columns.<#=propertyName #>); }
            set { SetColumnValue(Columns.<#=propertyName #>, value); }
        }

<#
        }
#>
        #endregion

<#
        DataTable PrimaryKeyRelations = schema.GetPrimaryKeyRelations(tableSchema, tableName);
        if (PrimaryKeyRelations.Rows.Count > 0)
        {
#>
        #region ' Primary key relations' Methods '

        protected override void SetPrimaryKey(object oValue)
        {
            base.SetPrimaryKey(oValue);
            SetPKValues();
        }

<#
            foreach (DataRow relationRow in PrimaryKeyRelations.Rows)
            {
                string fkTableName = relationRow["FK_TABLE_NAME"].ToString();
                string collectionClass = Inflector.MakeSingular(CleanName(fkTableName));
                string methodName = Inflector.MakePlural(CleanName(fkTableName));
                string fkPropertyName = CleanName(relationRow["FK_COLUMN_NAME"].ToString());
                string pkPropertyName = CleanName(relationRow["PK_COLUMN_NAME"].ToString());
#>
        public <#=Namespace #>.<#=collectionClass #>Collection <#=methodName #>Records()
        {
            return new <#=Namespace #>.<#=collectionClass #>Collection().Where(<#=collectionClass #>.Columns.<#=fkPropertyName #>, <#=pkPropertyName #>).Load();
        }

<#
            }
#>

        #endregion

<#
        }
        else
        {
#>
        // There are no primary key relations

<#
        }

        DataTable ForeignKeyRelations = schema.GetForeignKeyRelations(tableSchema, tableName);
        if (ForeignKeyRelations.Rows.Count > 0)
        {
#>
        #region ' Foreign key relations Methods '

<#
            foreach (DataRow relationRow in ForeignKeyRelations.Rows)
            {
                string pkTableName = relationRow["PK_TABLE_NAME"].ToString();
                string relatedClass = Inflector.MakeSingular(CleanName(pkTableName));
                string methodName = Inflector.MakeSingular(CleanName(pkTableName));
                string pkPropertyName = CleanName(relationRow["PK_COLUMN_NAME"].ToString());
                string fkColumnName = relationRow["FK_COLUMN_NAME"].ToString();
                string fkPropertyName = CleanName(fkColumnName);
#>
        /// <summary>
        /// Returns a <#=relatedClass #> ActiveRecord object related to this <#=className #>
        ///
        /// </summary>
        public <#=Namespace #>.<#=relatedClass #> <#=methodName #>Record
        {
            get { return <#=Namespace #>.<#=relatedClass #>.FetchByID(this.<#=fkPropertyName #>); }
            set { SetColumnValue("<#=fkColumnName #>", value.<#=pkPropertyName #>); }
        }

<#
            }
#>

        #endregion

<#
        }
        else
        {
#>
        // There are no foreign key relations

<#
    }
#>
        // No manytomany tables defined

        #region ' ObjectDataSource support '

<#
        StringBuilder insertParameters = new StringBuilder();
        StringBuilder updateParameters = new StringBuilder();
        foreach (DataRow columnRow in tableColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
            Type dataType = (Type)columnRow["DataType"];
            string systemType = schema.GetPropertyType(dataType.ToString());
            bool isAutoIncrement = (bool)columnRow["IsAutoIncrement"];

            if (insertParameters.Length > 0)
                insertParameters.Append(", ");
            insertParameters.AppendFormat("{0} {1}", systemType, propertyName);

            if (!isAutoIncrement)
            {
                if (updateParameters.Length > 0)
                    updateParameters.Append(", ");
                updateParameters.AppendFormat("{0} {1}", systemType, propertyName);
            }
        }
#>
        /// <summary>
        /// Inserts a record, can be used with the Object Data Source
        /// </summary>
        public static void Insert(<#=insertParameters.ToString() #>)
        {
            <#=className #> item = new <#=className #>();
<#
        foreach (DataRow columnRow in tableColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
#>
            item.<#=propertyName #> = <#=propertyName #>;
<#
        }
#>

            if (System.Web.HttpContext.Current != null)
                item.Save(System.Web.HttpContext.Current.User.Identity.Name);
            else
                item.Save(System.Threading.Thread.CurrentPrincipal.Identity.Name);
        }

        /// <summary>
        /// Updates a record, can be used with the Object Data Source
        /// </summary>
        public static void Update(<#=updateParameters.ToString() #>)
        {
            <#=className #> item = new <#=className #>();
<#
        foreach (DataRow columnRow in tableColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
            bool isAutoIncrement = (bool)columnRow["IsAutoIncrement"];
            if (!isAutoIncrement)
            {
#>
            item.<#=propertyName #> = <#=propertyName #>;
<#
            }
        }
#>
            item.IsNew = false;

            if (System.Web.HttpContext.Current != null)
                item.Save(System.Web.HttpContext.Current.User.Identity.Name);
            else
                item.Save(System.Threading.Thread.CurrentPrincipal.Identity.Name);
        }

        #endregion

        #region ' Typed Columns '

<#
        int columnCounter = 0;
        foreach (DataRow columnRow in tableColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
#>
        public static TableSchema.TableColumn <#=propertyName #>Column
        {
            get { return Schema.Columns[<#=columnCounter++ #>]; }
        }

<#
        }
#>
        #endregion

        #region ' Columns Struct '

        public struct Columns
        {
<#
        foreach (DataRow columnRow in tableColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
#>
            public static string <#=propertyName #> = @"<#=columnName #>";
<#
        }
#>
        }

        #endregion

        #region ' Update Primary Key Collections '

        public void SetPKValues()
        {
        }

        #endregion

        #region ' Deep Save '

        public void DeepSave()
        {
            Save();
        }

        #endregion

    }
<#
    }
#>



<#
    foreach (DataRow row in views.Rows)
    {
        string viewName = row["TABLE_NAME"].ToString();
        string className = Inflector.MakeSingular(CleanName(viewName));
        string viewSchema = row["TABLE_SCHEMA"].ToString();
        DataTable viewColumns = schema.GetTableColumns(viewSchema, viewName);
#>
    /// <summary>
    /// Strongly-typed collection for the <#=className #> class.
    /// </summary>

    [Serializable]
    public partial class <#=className #>Collection : ReadOnlyList<<#=className #>, <#=className #>Collection>
    {
        public <#=className #>Collection() {}
    }

    /// <summary>
    /// This is read-only wrapper class for the <#=viewName #> view.
    /// </summary>
    [Serializable]
    public partial class <#=className #> : ReadOnlyRecord<<#=className #>>, IReadOnlyRecord
    {

        #region ' Default Settings '

        protected static void SetSQLProps()
        {
            GetTableSchema();
        }

        #endregion

        #region ' Schema Accessor '

        public static TableSchema.Table Schema
        {
            get
            {
                if (BaseSchema == null)
                {
                    SetSQLProps();
                }
                return BaseSchema;
            }
        }

        private static void GetTableSchema()
        {
            if(!IsSchemaInitialized)
            {
                //Schema declaration
                TableSchema.Table schema = new TableSchema.Table("<#=viewName #>", TableType.View, DataService.GetInstance("<#=ConnectionName #>"));
                schema.Columns = new TableSchema.TableColumnCollection();
                schema.SchemaName = @"<#=viewSchema #>";

                //Columns
<#
        foreach (DataRow columnRow in viewColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
            DbType dbType = schema.GetDbColumnType(columnRow["ProviderType"].ToString());
            Type dataType = (Type)columnRow["DataType"];
            string systemType = schema.GetPropertyType(dataType.ToString());
            string ColumnSize = "0";
            if (systemType == "string")
                ColumnSize = columnRow["ColumnSize"].ToString();
            bool isAutoIncrement = (bool)columnRow["IsAutoIncrement"];
            bool isNullable = (bool)columnRow["AllowDBNull"];
            bool isReadOnly = (bool)columnRow["IsReadOnly"];
#>
                TableSchema.TableColumn column<#=propertyName #> = new TableSchema.TableColumn(schema);
                column<#=propertyName #>.ColumnName = "<#=columnName #>";
                column<#=propertyName #>.DataType = DbType.<#=dbType.ToString() #>;
                column<#=propertyName #>.MaxLength = <#=ColumnSize #>;
                column<#=propertyName #>.AutoIncrement = <#=isAutoIncrement.ToString().ToLower() #>;
                column<#=propertyName #>.IsNullable = <#=isNullable.ToString().ToLower() #>;
                column<#=propertyName #>.IsPrimaryKey = false;
                column<#=propertyName #>.IsForeignKey = false;
                column<#=propertyName #>.IsReadOnly = <#=isReadOnly.ToString().ToLower() #>;
                schema.Columns.Add(column<#=propertyName #>);

<#
        }
#>
                BaseSchema = schema;
                //add this schema to the provider
                //so we can query it later
                DataService.Providers["<#=ConnectionName #>"].AddSchema("<#=viewName #>", schema);
            }
        }

        #endregion
        
        #region ' Query Accessor '
        
	    public static Query CreateQuery()
	    {
		    return new Query(Schema);
	    }
	    
	    #endregion

	    #region ' .Ctors '
	    
	    public <#=className #>()
	    {
            SetSQLProps();
            SetDefaults();
            MarkNew();
        }

        public <#=className #>(bool useDatabaseDefaults)
	    {
		    SetSQLProps();
		    if(useDatabaseDefaults)
		    {
				ForceDefaults();
			}
			MarkNew();
	    }
	    
	    public <#=className #>(object keyID)
	    {
		    SetSQLProps();
		    LoadByKey(keyID);
	    }
    	 
	    public <#=className #>(string columnName, object columnValue)
        {
            SetSQLProps();
            LoadByParam(columnName,columnValue);
        }
        
	    #endregion

        #region ' Properties '

<#
        foreach (DataRow columnRow in viewColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
            DbType dbType = schema.GetDbColumnType(columnRow["ProviderType"].ToString());
            Type dataType = (Type)columnRow["DataType"];
            string systemType = schema.GetPropertyType(dataType.ToString());
#>
        [XmlAttribute("<#=propertyName #>")]
        [Bindable(true)]
        public <#=systemType #> <#=propertyName #>
        {
            get { return GetColumnValue<<#=systemType #>>(Columns.<#=propertyName #>); }
            set { SetColumnValue(Columns.<#=propertyName #>, value); }
        }

<#
        }
#>
        #endregion

	    #region ' Columns Struct '
	    
	    public struct Columns
	    {
<#
        foreach (DataRow columnRow in viewColumns.Rows)
        {
            string columnName = columnRow["ColumnName"].ToString();
            string propertyName = CleanName(columnName);
#>
            public static string <#=propertyName #> = @"<#=columnName #>";
<#
        }
#>
        }

	    #endregion

	    #region ' IAbstractRecord Members '

        public new CT GetColumnValue<CT>(string columnName)
        {
            return base.GetColumnValue<CT>(columnName);
        }

        public object GetColumnValue(string columnName)
        {
            return base.GetColumnValue<object>(columnName);
        }

        #endregion

    }

<#
    }
#>
}